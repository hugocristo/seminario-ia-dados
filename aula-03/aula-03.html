<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Seminário de Metodologia de Pesquisa X (PPGP-0114) - 2025/2: Aula 03</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="aula-03_files/libs/clipboard/clipboard.min.js"></script>
<script src="aula-03_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="aula-03_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="aula-03_files/libs/quarto-html/popper.min.js"></script>
<script src="aula-03_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="aula-03_files/libs/quarto-html/anchor.min.js"></script>
<link href="aula-03_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="aula-03_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="aula-03_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="aula-03_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="aula-03_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="aulas.css">
</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#introdução" id="toc-introdução" class="nav-link active" data-scroll-target="#introdução">1. Introdução</a></li>
  <li><a href="#medidas-e-representações-discretas" id="toc-medidas-e-representações-discretas" class="nav-link" data-scroll-target="#medidas-e-representações-discretas">2. Medidas e representações discretas</a>
  <ul>
  <li><a href="#morfologia" id="toc-morfologia" class="nav-link" data-scroll-target="#morfologia">2.1 Morfologia</a>
  <ul class="collapse">
  <li><a href="#tokenização" id="toc-tokenização" class="nav-link" data-scroll-target="#tokenização">Tokenização</a></li>
  <li><a href="#visualização-da-distribuição" id="toc-visualização-da-distribuição" class="nav-link" data-scroll-target="#visualização-da-distribuição">Visualização da distribuição</a></li>
  <li><a href="#lematização-e-radicalização" id="toc-lematização-e-radicalização" class="nav-link" data-scroll-target="#lematização-e-radicalização">Lematização e radicalização</a></li>
  </ul></li>
  <li><a href="#sintaxe" id="toc-sintaxe" class="nav-link" data-scroll-target="#sintaxe">2.2 Sintaxe</a>
  <ul class="collapse">
  <li><a href="#explorando-n-grams" id="toc-explorando-n-grams" class="nav-link" data-scroll-target="#explorando-n-grams">Explorando n-grams</a></li>
  <li><a href="#ampliando-a-janela" id="toc-ampliando-a-janela" class="nav-link" data-scroll-target="#ampliando-a-janela">Ampliando a janela</a></li>
  </ul></li>
  <li><a href="#semântica" id="toc-semântica" class="nav-link" data-scroll-target="#semântica">2.3 Semântica</a>
  <ul class="collapse">
  <li><a href="#a-frequência-relativa-da-palavra-tf" id="toc-a-frequência-relativa-da-palavra-tf" class="nav-link" data-scroll-target="#a-frequência-relativa-da-palavra-tf">A frequência relativa da palavra: <em>tf</em></a></li>
  <li><a href="#a-informação-transmitida-pela-palavra-quanto-à-coleção-idf" id="toc-a-informação-transmitida-pela-palavra-quanto-à-coleção-idf" class="nav-link" data-scroll-target="#a-informação-transmitida-pela-palavra-quanto-à-coleção-idf">A informação transmitida pela palavra quanto à coleção: <em>idf</em></a></li>
  <li><a href="#a-medida-da-importância-do-termo-tf-idf" id="toc-a-medida-da-importância-do-termo-tf-idf" class="nav-link" data-scroll-target="#a-medida-da-importância-do-termo-tf-idf">A medida da importância do termo: <em>tf-idf</em></a></li>
  </ul></li>
  </ul></li>
  <li><a href="#atividade" id="toc-atividade" class="nav-link" data-scroll-target="#atividade">Atividade</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Seminário de Metodologia de Pesquisa X (PPGP-0114) - 2025/2: Aula 03</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<ul>
<li>Tema: Análise Computacional de Dados Textuais</li>
<li>Responsável: Prof.&nbsp;Dr.&nbsp;Hugo Cristo Sant’Anna - <a href="mailto:hugo.santanna@ufes.br">hugo.santanna@ufes.br</a></li>
</ul>
<section id="introdução" class="level1">
<h1>1. Introdução</h1>
<p>A linguística, enquanto ciência que estuda a linguagem, é tradicionalmente dividida em <em>Fonética e fonologia</em>, <em>Morfologia</em>, <em>Sintaxe</em>, <em>Semântica</em> e <em>Pragmática</em>. Este seminário investigará aspectos de quatro dessas subáreas:</p>
<ul>
<li>A <em>Morfologia</em> se dedica à segmentação e desambiguação de textos em <em>unidades linguísticas</em> e suas variações (p.ex., número, gênero, classes gramaticais) adequadas para realizar o processamento dos conjuntos de dados.</li>
<li>A <em>Sintaxe</em> trata da ordenação das unidades linguísticas, de modo que se expresse o significado esperado.</li>
<li>A <em>Semântica</em> lida com o significado das unidades (<em>lexical</em>) e expressões (<em>composicional</em>) que agrupam as unidades.</li>
<li><em>Pragmática</em> considera os efeitos do contexto para desambiguar o significado de expressões.</li>
</ul>
<p>A vertente <em>computacional</em> da linguística, especialmente por meio do <em>processamento de linguagem natural</em> (<em>Natural Language Processing</em> ou NLP), se dedica ao desenvolvimento de aplicações computacionais envolvendo aquelas subáreas.</p>
<p>A obra <a href="https://acervo.ufes.br/acervo/165998/">“Teoria linguística: teoria lexical e linguística computacional”</a>, de Maria Tereza Camargo Biderman (2ª ed., 2001) deve ser consultada para aprofundamentos das teorias sobre a linguagem.</p>
<p>A hipótese distribucionalista, como proposta por <a href="https://www.zelligharris.org/#:~:text=Distributional">Zellig Harris (1954)</a>, será utilizada para ilustrar aspectos da face quantitativa da linguagem. A revisão de <a href="https://doi.org/10.1146/annurev-linguistics-030514-125254">Alessandro Lenci (2017)</a> inclui aspectos históricos e técnicos da discussão.</p>
<p>Como apoio, recomendamos os vídeos gratuitos da série <a href="https://www.youtube.com/watch?v=T4_J6Q2E4k0&amp;list=PLLrlHSmC0Mw73a1t73DEjgGMPyu8QssWT">Linguística Computacional</a>, do Prof.&nbsp;Thiago Castro Ferreira da UFMG, e na série <a href="https://www.youtube.com/playlist?list=PLTKMiZHVd_2IIEsoJrWACkIxLRdfMlw11">Build a Large Language Model from Scratch</a>, de Sebastian Raschka.</p>
<p>Para fins de ilustração, utilizaremos uma coleção de textos de Machado de Assis, publicados entre 1870 e 1879. O acesso a este <em>corpus</em> foi facilitado para as demonstrações a seguir, mas realizaremos o processo completo de obtenção dos corpora completos de Machado de Assis na aula 04.</p>
</section>
<section id="medidas-e-representações-discretas" class="level1">
<h1>2. Medidas e representações discretas</h1>
<p>O matemático francês <a href="https://api.pageplace.de/preview/DT0400.9783112415443_A44908668/preview-9783112415443_A44908668.pdf">Gustav Herdan (1962)</a> argumentou que, do ponto de vista estatístico, a <em>fala</em> (e seus registros) é uma amostra da <em>língua</em>, que seria a população. Como consequência, haveria condicionantes para o uso da língua pelos indivíduos que poderiam ser identificadas por meio de análises de natureza quantitativa.</p>
<p><a href="https://www.zelligharris.org/#:~:text=Distributional">Harris (1954)</a> especificou as bases e uma proposta de método estruturalista e distribucionalista da linguagem. Os <a href="./slides/ppgp-dados-ia-aula03-protegido.pdf">slides</a> apresentados durante a aula destacam aspectos relevantes do artigo e ilustram suas aplicações à análise de dados textuais.</p>
<section id="morfologia" class="level2">
<h2 class="anchored" data-anchor-id="morfologia">2.1 Morfologia</h2>
<p>O estudo morfológico de conjuntos de texto se inicia pela <em>normalização</em>, que visa uniformizá-los para tornar o processamento mais conveniente. Os resultados da normalização incluem a contagem de palavras, expressões, sentenças e a identificação de radicais de palavras.</p>
<p>A normalização procede por quatro etapas:</p>
<ol type="1">
<li><em>Tokenização</em>: distingue unidades linguísticas de textos (<em>tokens</em>), tendo a palavra como escolha mais frequente;</li>
<li><em>Tokenização de sentenças</em>: distinção de combinações de <em>tokens</em> para análise;</li>
<li><em>Lematização</em>: trata as unidades linguísticas de modo a selecionar formas convencionadas (dicionarizadas) — <em>lemas</em>;</li>
<li><em>Radicalização</em>: redução das unidades linguísticas ao morfema básico.</li>
</ol>
<section id="tokenização" class="level3">
<h3 class="anchored" data-anchor-id="tokenização">Tokenização</h3>
<p>A tokenização é a tarefa mais importante da normalização de texto, geralmente compreendendo o passo inicial da preparação de todos os modelos de linguística computacional, inclusive os modelos de linguagem de larga escala utilizados nas inteligências artificiais generativas.</p>
<p>Considere os cinco primeiro versos da primeira estrofe de “Potira”, de Machado de Assis (1875):</p>
<pre><code>Moça cristã das solidões antigas,
Em que áurea folha reviveu teu nome?
Nem o eco das matas seculares,
Nem a voz das sonoras cachoeiras,
O transmitiu aos séculos futuros.</code></pre>
<p>O código abaixo carrega um arquivo de texto e atribui seu conteúdo à variável <code>potira</code>. O processo é diferente daquele visto na aula passada, pois depende da abertura de um fluxo de dados.</p>
<div id="cell-3" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># abre fluxo de dados de leitura</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>fluxo <span class="ot">&lt;-</span> <span class="fu">file</span>(<span class="st">"potira.txt"</span>,<span class="at">open=</span><span class="st">"r"</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co"># lê as linhas para o vetor 'potira'</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>potira <span class="ot">&lt;-</span> <span class="fu">readLines</span>(fluxo)</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"># fecha fluxo</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="fu">close</span>(fluxo)</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co"># exibe versos (linhas 9 a 13)</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>versos <span class="ot">&lt;-</span> potira[<span class="dv">9</span><span class="sc">:</span><span class="dv">13</span>]</span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="fu">print</span>(versos)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Moça cristã das solidões antigas,"   
[2] "Em que áurea folha reviveu teu nome?"
[3] "Nem o eco das matas seculares,"      
[4] "Nem a voz das sonoras cachoeiras,"   
[5] "O transmitiu aos séculos futuros."   </code></pre>
</div>
</div>
<p>O processo de tokenização pressupõe algum critério para a definição das unidades linguísticas em um dado idioma.</p>
<p>O pacote <code>stringr</code>, por meio da função <code>str_split()</code>, pode tokenizar conjuntos de texto por diversos critérios:</p>
<div id="cell-5" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># instala e carrega o pacote</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="fu">install.packages</span>(<span class="st">'stringr'</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="fu">library</span>(stringr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package ‘stringr’ is in use and will not be installed</code></pre>
</div>
</div>
<p>O critério mais simples é o <em>espaço</em> entre as unidades.</p>
<div id="cell-7" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># tokeniza o vetor verso por espaços</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="fu">str_split</span>(versos, <span class="st">" "</span>, <span class="at">simplify =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>     [,1]   [,2]         [,3]    [,4]       [,5]       [,6]          [,7]   
[1,] "Moça" "cristã"     "das"   "solidões" "antigas," ""            ""     
[2,] "Em"   "que"        "áurea" "folha"    "reviveu"  "teu"         "nome?"
[3,] "Nem"  "o"          "eco"   "das"      "matas"    "seculares,"  ""     
[4,] "Nem"  "a"          "voz"   "das"      "sonoras"  "cachoeiras," ""     
[5,] "O"    "transmitiu" "aos"   "séculos"  "futuros." ""            ""     </code></pre>
</div>
</div>
<p>Há diversos problemas com a tokenização baseada em espaços:</p>
<ol type="1">
<li>Espaços vazios são transformados em <em>tokens</em>;</li>
<li>Sinais de pontuação estão combinados às unidades, como em <code>antigas,</code>, <code>cachoeiras,</code> e <code>futuros.</code></li>
</ol>
<p>Expressões regulares são sequências de caracteres que definem padrões de busca mais robustos que separadores simples e aprimoram o processo de tokenização. A função <code>boundary()</code> identifica limites do tipo <code>character</code> (caractere), <code>line_break</code> (quebra de linha), <code>sentence</code> (sentença) e <code>word</code> (palavra).</p>
<div id="cell-9" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># tokeniza pelos limites da palavra</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co"># str_split() retorna uma lista e unlist() transforma em vetor</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>tokens <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">str_split</span>(versos,<span class="fu">boundary</span>(<span class="st">'word'</span>)))</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="fu">print</span>(tokens)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "Moça"       "cristã"     "das"        "solidões"   "antigas"   
 [6] "Em"         "que"        "áurea"      "folha"      "reviveu"   
[11] "teu"        "nome"       "Nem"        "o"          "eco"       
[16] "das"        "matas"      "seculares"  "Nem"        "a"         
[21] "voz"        "das"        "sonoras"    "cachoeiras" "O"         
[26] "transmitiu" "aos"        "séculos"    "futuros"   </code></pre>
</div>
</div>
<p>A estrofe produziu 26 <em>tokens</em>, sendo alguns repetidos. Podemos gerar a frequência deles com a função <code>table()</code>, já conhecida:</p>
<div id="cell-11" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># total de tokens únicos</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Total de tokens:"</span>,<span class="fu">length</span>(tokens),<span class="st">"/ total de tokens únicos:"</span>,<span class="fu">length</span>(<span class="fu">unique</span>(tokens))))</span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co"># calcula a ocorrência dos tokens</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="fu">table</span>(tokens)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Total de tokens: 29 / total de tokens únicos: 26"</code></pre>
</div>
<div class="cell-output cell-output-display">
<pre><code>tokens
         a    antigas        aos      áurea cachoeiras     cristã        das 
         1          1          1          1          1          1          3 
       eco         Em      folha    futuros      matas       Moça        Nem 
         1          1          1          1          1          1          2 
      nome          o          O        que    reviveu  seculares    séculos 
         1          1          1          1          1          1          1 
  solidões    sonoras        teu transmitiu        voz 
         1          1          1          1          1 </code></pre>
</div>
</div>
<p>A tabela indica a ocorrência de três (3) tokens <code>das</code> e dois (2) tokens <code>Nem</code>, explicando a diferença entre o total de ocorrências e o total de tokens.</p>
<blockquote class="blockquote">
<p><strong>Dica:</strong> denominamos <em>vocabulário</em> o conjunto de tokens identificados em dados textuais.</p>
</blockquote>
<p>Podemos refazer as operações com o poema completo, para analisar a distribuição de frequências dos <em>tokens</em> no vocabulário.</p>
<div id="cell-13" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># tokeniza vetor completo do poema</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>tokens <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">str_split</span>(potira,<span class="fu">boundary</span>(<span class="st">'word'</span>)))</span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co"># informa a quantidade de tokens</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Total de tokens:"</span>,<span class="fu">length</span>(tokens),<span class="st">"/ total de tokens únicos:"</span>,<span class="fu">length</span>(<span class="fu">unique</span>(tokens))))</span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="co"># gera a tabela e exibe as 80 primeiras palavras</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="fu">head</span>(<span class="fu">table</span>(tokens),<span class="at">n=</span><span class="dv">80</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Total de tokens: 4136 / total de tokens únicos: 1866"</code></pre>
</div>
<div class="cell-output cell-output-display">
<pre><code>tokens
         3º           a           A           á           à           À 
          1         119          34           1          23           4 
abandonaste  Abatimento      aberta    abicando     abóbada      abrasa 
          1           1           1           1           1           1 
       abre       Abrem   abreviada       abria       abriu      acabou 
          1           1           1           1           1           1 
     acácia       acaso       Acaso      aceita      acende     acender 
          1           1           2           1           2           1 
     acolhe   acometido acompanhado      acorda    Acordará      acorre 
          1           1           1           4           1           1 
Adelgaçando  adormecido    Adornada      afoito     afronta   afrontado 
          1           1           1           1           1           1 
      agita    agitação        agra        água     aguarda       águas 
          1           1           1           1           4           4 
    aguçado          Ah          ai          Ai       ainda         ais 
          1           2           1           2           2           1 
   alardeam  Alcatifado       Alçou      aldeia     aldeias      alegre 
          1           1           1           6           1           3 
    alegres     alegria        além   Alevantar       Alfim       algoz 
          2           3           2           1           1           1 
     alguma     algumas     Algumas      alguns      Alguns     Alheias 
          1           2           1           1           1           1 
     alheio         ali      alívio        alma        almo    alumiada 
          1           4           1           7           1           1 
    alumiar        alva        Alva       alvas      alveja      Alveja 
          1           1           1           1           2           1 
       alvo       alvos 
          2           1 </code></pre>
</div>
</div>
<p>A tabela gerada, com 1866 itens, indica alguns problemas que a normalização ainda precisa resolver. Variações do mesmo <em>token</em> são contabilizadas de modo independente, tais como <code>alguma</code> e <code>algumas</code> (variação de número), <code>algumas</code> e <code>Algumas</code> ou <code>alguns</code> e <code>Alguns</code> (diferença no uso da letra maiúscula). Essa padronização pode reduzir o número de itens e aprimorar a avaliação da distribuição.</p>
<p>As funções <code>str_to_lower()</code> e <code>str_to_upper()</code> transformam, respectivamente, os conjuntos de textos para letras minúsculas e maiúsculas. Assim, casos como <code>Algumas</code> e <code>algumas</code> seriam contabilizados conjuntamente.</p>
<div id="cell-15" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># converte para minúsculas</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>tokens.minusculas <span class="ot">&lt;-</span> <span class="fu">str_to_lower</span>(potira)</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co"># tokeniza vetor completo do poema</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>tokens.minusculas <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">str_split</span>(tokens.minusculas,<span class="fu">boundary</span>(<span class="st">'word'</span>)))</span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="co"># informa a quantidade de tokens</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Total de tokens:"</span>,<span class="fu">length</span>(tokens.minusculas),<span class="st">"/ total de tokens únicos:"</span>,<span class="fu">length</span>(<span class="fu">unique</span>(tokens.minusculas))))</span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="co"># gera a tabela e exibe as 80 primeiras palavras</span></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="fu">head</span>(<span class="fu">table</span>(tokens.minusculas),<span class="at">n=</span><span class="dv">80</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Total de tokens: 4136 / total de tokens únicos: 1679"</code></pre>
</div>
<div class="cell-output cell-output-display">
<pre><code>tokens.minusculas
         3º           a           á           à abandonaste  abatimento 
          1         153           1          27           1           1 
     aberta    abicando     abóbada      abrasa        abre       abrem 
          1           1           1           1           1           1 
  abreviada       abria       abriu      acabou      acácia       acaso 
          1           1           1           1           1           3 
     aceita      acende     acender      acolhe   acometido acompanhado 
          1           2           1           1           1           1 
     acorda    acordará      acorre adelgaçando  adormecido    adornada 
          4           1           1           1           1           1 
     afoito     afronta   afrontado       agita    agitação        agra 
          1           1           1           1           1           1 
       água     aguarda       águas     aguçado          ah          ai 
          1           4           4           1           2           3 
      ainda         ais    alardeam  alcatifado       alçou      aldeia 
          2           1           1           1           1           6 
    aldeias      alegre     alegres     alegria        além   alevantar 
          1           3           2           3           2           1 
      alfim       algoz      alguma     algumas      alguns     alheias 
          1           1           1           3           2           1 
     alheio         ali      alívio        alma        almo    alumiada 
          1           4           1           7           1           1 
    alumiar        alva       alvas      alveja        alvo       alvos 
          1           2           1           3           2           1 
      amado      amante    amarelas      amargo      amaste       ambos 
          1           1           1           2           1           3 
     ameaça       ameno 
          1           1 </code></pre>
</div>
</div>
<p>O ajuste reduziu a listagem em quase 200 <em>tokens</em>, reforçando a importância da normalização do texto antes da análise. Podemos prosseguir para formas mais avançadas de normalização.</p>
</section>
<section id="visualização-da-distribuição" class="level3">
<h3 class="anchored" data-anchor-id="visualização-da-distribuição">Visualização da distribuição</h3>
<p>A necessidade de normalização do corpus pode ser verificada por meio de dispositivos de informação como nuvens de palavras (<em>word clouds</em>).</p>
<p>Ferramentas online como <a href="https://www.freewordcloudgenerator.com/generatewordcloud">Free Word Cloud Generator</a> exibem <em>tokens</em> do vocabulário em tamanho proporcional à sua frequência no corpus, facilitando a avaliação da distribuição.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./imagens/wordcloud.png" class="img-fluid figure-img"></p>
<figcaption>Nuvem de palavras do poema Potira.</figcaption>
</figure>
</div>
<p>A imagem, resultado do processo de copiar e colar o poema original na ferramenta, evidencia como as chamadas <em>palavras de parada</em> (<em>stopwords</em>) ou <em>palavras vazias</em> (<em>empty words</em>) podem prejudicar a análise.</p>
<p>Exceto por termos como “rosto”, “olhos”, “flor”, “vida”, as palavras representadas em maior não contribuem para a compreensão dos significados no texto.</p>
<p>A lista de tokens do vetor <code>tokens.minusculas</code> pode ser aprimorada pela remoção das palavras de parada, passando a fornecer indícios mais relevantes sobre a estrutura do texto. O pacote <code>stopwords</code> contém um dicionário com palavras de parada em vários idiomas, inclusive o português.</p>
<div id="cell-18" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a><span class="co"># instala e carrega pacote</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="fu">install.packages</span>(<span class="st">'stopwords'</span>)</span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="fu">library</span>(stopwords)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package ‘stopwords’ is in use and will not be installed</code></pre>
</div>
</div>
<p>Removeremos as palavras de parada de <code>tokens.minusculas</code> utilizando a função <code>stopwords()</code> com o argumento <code>pt-br</code>. Utilizamos, ademais, a função <code>which()</code> e o operador <code>%in%</code>, que verifica se um item pertence a um conjunto.</p>
<p>A variável <code>remover</code> contém os índices dos itens do vetor <code>tokens.minusculas</code> que também estão na lista das palavras de parada do português.</p>
<div id="cell-20" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a><span class="co"># lista de termos para remover</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>remover <span class="ot">&lt;-</span> <span class="fu">which</span>(tokens.minusculas <span class="sc">%in%</span> <span class="fu">stopwords</span>(<span class="st">'pt'</span>))</span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="co"># mostra a lista</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="fu">print</span>(remover)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   [1]    1    3    6    9   11   12   14   16   22   25   26   28   30   31
  [15]   32   35   37   38   39   44   45   47   49   50   53   54   56   58
  [29]   59   61   63   65   70   72   79   82   83   87   89   90   92   95
  [43]   96   98  101  103  107  110  115  117  119  121  122  125  128  132
  [57]  134  135  137  140  141  142  151  153  155  157  163  166  168  169
  [71]  170  173  174  176  178  181  182  185  187  188  191  192  195  202
  [85]  205  207  213  215  219  223  226  231  234  238  239  242  244  245
  [99]  248  251  254  257  259  262  265  267  268  272  279  282  283  287
 [113]  288  290  293  296  298  303  306  308  311  312  316  318  321  324
 [127]  328  332  335  339  340  341  342  344  347  348  351  354  356  360
 [141]  363  365  368  374  376  379  381  382  386  387  389  391  393  395
 [155]  399  402  403  405  407  410  413  414  416  418  419  422  423  425
 [169]  427  429  430  433  435  438  442  445  447  449  451  454  456  458
 [183]  460  461  462  464  465  467  469  472  474  476  479  480  482  485
 [197]  486  488  489  492  494  496  498  500  501  502  504  507  509  510
 [211]  518  522  527  528  530  534  535  537  538  540  543  547  550  552
 [225]  556  563  564  566  567  569  570  572  573  575  579  581  587  590
 [239]  593  600  602  605  606  607  614  617  620  622  623  625  627  631
 [253]  634  636  639  642  643  646  649  655  658  663  667  669  671  672
 [267]  676  677  678  681  684  686  689  691  696  699  702  704  706  709
 [281]  714  717  718  721  731  733  735  738  741  744  748  756  757  760
 [295]  763  765  768  770  773  775  777  778  780  782  785  788  792  797
 [309]  799  801  803  805  809  814  817  818  820  822  824  826  829  832
 [323]  834  838  839  840  842  847  848  850  851  853  855  856  859  862
 [337]  863  867  869  871  873  874  875  877  880  882  883  884  887  890
 [351]  891  893  897  899  901  903  906  909  913  915  922  924  925  926
 [365]  931  933  936  938  940  944  947  948  952  953  956  961  963  965
 [379]  967  970  972  978  980  983  985  988  992  994 1002 1007 1011 1012
 [393] 1013 1019 1021 1023 1024 1026 1029 1035 1037 1039 1042 1043 1044 1045
 [407] 1047 1050 1052 1054 1055 1057 1060 1062 1063 1068 1070 1074 1077 1078
 [421] 1079 1080 1082 1086 1087 1088 1089 1091 1092 1094 1095 1100 1102 1103
 [435] 1104 1108 1109 1110 1113 1116 1120 1122 1124 1129 1131 1134 1136 1142
 [449] 1146 1148 1151 1152 1153 1155 1156 1158 1159 1161 1163 1166 1167 1168
 [463] 1171 1172 1173 1174 1178 1180 1182 1183 1186 1188 1191 1192 1193 1196
 [477] 1197 1200 1202 1204 1205 1207 1209 1210 1212 1214 1215 1218 1221 1222
 [491] 1223 1226 1228 1230 1233 1235 1237 1240 1241 1243 1246 1247 1250 1251
 [505] 1252 1253 1261 1264 1267 1270 1271 1273 1276 1280 1281 1283 1289 1291
 [519] 1292 1295 1297 1299 1300 1302 1303 1304 1305 1309 1311 1314 1315 1318
 [533] 1321 1324 1326 1328 1332 1333 1335 1338 1340 1343 1345 1346 1351 1354
 [547] 1359 1362 1368 1371 1375 1376 1378 1379 1381 1383 1385 1388 1390 1394
 [561] 1396 1399 1402 1403 1404 1406 1408 1409 1410 1413 1416 1417 1419 1420
 [575] 1421 1424 1425 1427 1429 1430 1433 1438 1441 1445 1446 1448 1449 1452
 [589] 1454 1458 1459 1462 1470 1474 1476 1482 1483 1486 1488 1489 1490 1492
 [603] 1494 1496 1498 1502 1504 1506 1508 1509 1510 1515 1516 1518 1520 1521
 [617] 1525 1528 1535 1539 1541 1542 1544 1548 1551 1553 1555 1557 1562 1566
 [631] 1567 1569 1574 1576 1579 1583 1589 1591 1594 1596 1599 1601 1602 1606
 [645] 1608 1610 1612 1616 1619 1624 1625 1626 1628 1631 1634 1636 1637 1638
 [659] 1642 1644 1645 1649 1650 1653 1655 1658 1660 1663 1666 1667 1670 1672
 [673] 1677 1679 1684 1688 1689 1691 1696 1700 1701 1703 1706 1707 1708 1710
 [687] 1715 1717 1718 1719 1722 1727 1732 1733 1738 1740 1741 1742 1744 1745
 [701] 1746 1748 1752 1754 1755 1758 1759 1762 1767 1769 1772 1775 1777 1779
 [715] 1781 1784 1786 1787 1791 1792 1794 1796 1797 1800 1802 1805 1807 1809
 [729] 1810 1814 1816 1817 1819 1820 1821 1822 1824 1826 1828 1829 1832 1835
 [743] 1838 1841 1842 1845 1849 1851 1852 1855 1856 1857 1859 1861 1863 1867
 [757] 1871 1873 1876 1877 1879 1881 1884 1888 1891 1892 1894 1896 1899 1902
 [771] 1903 1906 1913 1915 1918 1920 1922 1925 1926 1928 1929 1930 1932 1937
 [785] 1940 1942 1944 1949 1951 1954 1959 1961 1963 1965 1966 1968 1970 1971
 [799] 1973 1974 1976 1982 1984 1986 1989 1990 1992 1995 1997 1998 2000 2003
 [813] 2005 2009 2010 2011 2013 2016 2019 2022 2024 2026 2027 2032 2036 2037
 [827] 2038 2040 2042 2043 2047 2050 2052 2054 2055 2057 2062 2065 2067 2068
 [841] 2069 2071 2073 2075 2077 2080 2082 2087 2088 2090 2091 2094 2097 2100
 [855] 2103 2104 2107 2110 2114 2115 2117 2120 2122 2123 2126 2129 2133 2134
 [869] 2137 2140 2142 2144 2146 2147 2148 2149 2151 2153 2156 2160 2163 2165
 [883] 2166 2168 2172 2179 2182 2185 2186 2189 2190 2191 2196 2199 2203 2207
 [897] 2208 2209 2210 2211 2212 2216 2217 2220 2227 2228 2230 2233 2236 2237
 [911] 2241 2244 2246 2248 2251 2254 2258 2260 2261 2264 2268 2271 2272 2275
 [925] 2277 2279 2281 2283 2290 2291 2294 2296 2299 2302 2304 2306 2308 2311
 [939] 2312 2313 2319 2320 2321 2322 2326 2327 2331 2336 2337 2339 2341 2345
 [953] 2347 2352 2357 2359 2361 2362 2364 2368 2370 2371 2374 2376 2377 2381
 [967] 2385 2386 2388 2391 2394 2395 2399 2402 2404 2407 2412 2414 2415 2418
 [981] 2420 2422 2425 2427 2429 2431 2434 2437 2441 2445 2446 2448 2452 2454
 [995] 2457 2458 2460 2466 2468 2471
 [ reached 'max' / getOption("max.print") -- omitted 627 entries ]</code></pre>
</div>
</div>
<p>Desse modo, podemos criar o novo vetor <code>tokens.nuvem</code> apenas com <em>tokens</em> não removidos da lista original.</p>
<div id="cell-22" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a><span class="co"># cria novo vetor</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>tokens.nuvem <span class="ot">&lt;-</span> tokens.minusculas[<span class="sc">-</span>remover]</span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="co"># distribuição resultante</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Total de tokens:"</span>,<span class="fu">length</span>(tokens.nuvem),<span class="st">"/ total de tokens únicos:"</span>,<span class="fu">length</span>(<span class="fu">unique</span>(tokens.nuvem))))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Total de tokens: 2509 / total de tokens únicos: 1572"</code></pre>
</div>
</div>
<p>Obtivemos 100 tokens a menos, sendo que a frequência total caiu em 1627 ocorrências. Isto significa que os termos removidos eram muito frequentes e não tinham papel relevante na construção do significado. Podemos visualizar o resultado em nuvens de palavras com o pacote <code>wordcloud</code>.</p>
<div id="cell-24" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a><span class="co"># instala e carrega pacote</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="fu">install.packages</span>(<span class="st">'wordcloud'</span>)</span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="fu">library</span>(wordcloud)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package ‘wordcloud’ is in use and will not be installed</code></pre>
</div>
</div>
<p>A função <code>wordcloud()</code> recebe dois argumentos: um vetor com a lista de palavras e outro com a frequência de cada palavra.</p>
<div id="cell-26" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a><span class="co"># converte vetor para data.frame</span></span>
<span id="cb27-2"><a href="#cb27-2"></a>tokens.nuvem.df <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">table</span>(tokens.nuvem))</span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="co"># remove margins para comportar a nuvem</span></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>))</span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="co"># gera nuvem</span></span>
<span id="cb27-6"><a href="#cb27-6"></a><span class="fu">wordcloud</span>(tokens.nuvem.df<span class="sc">$</span>tokens.nuvem, tokens.nuvem.df<span class="sc">$</span>Freq, <span class="at">colors=</span><span class="fu">brewer.pal</span>(<span class="dv">8</span>, <span class="st">"Spectral"</span>),<span class="at">random.order=</span><span class="cn">FALSE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="aula-03_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Podemos observar que a palavra de frequência mais alta é “olhos”, seguida por “vida” e “mãos”, depois por “rosto”, “voz” e “amor”. As cores agrupam os termos com a mesma ocorrência, relevando aspectos <em>quantitativos</em> da estrutura do texto.</p>
<p>Se o resultado ainda não for satisfatório, podemos utilizar listas personalizadas de palavras de parada, refinadas de acordo com o nosso interesse.</p>
<div id="cell-28" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a><span class="co"># cria vetor com palavras que desejamos remover</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>palavras.de.parada <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'é'</span>,<span class="st">'la'</span>,<span class="st">'tal'</span>,<span class="st">'oh'</span>,<span class="st">'aí'</span>,<span class="st">'ai'</span>,<span class="st">'ali'</span>,<span class="st">'ó'</span>)</span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="co"># lista de termos para remover</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>remover <span class="ot">&lt;-</span> <span class="fu">which</span>(tokens.nuvem <span class="sc">%in%</span> palavras.de.parada)</span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="co"># remove</span></span>
<span id="cb28-6"><a href="#cb28-6"></a>tokens.nuvem <span class="ot">&lt;-</span> tokens.nuvem[<span class="sc">-</span>remover]</span>
<span id="cb28-7"><a href="#cb28-7"></a><span class="co"># distribuição resultante</span></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Total de tokens:"</span>,<span class="fu">length</span>(tokens.nuvem),<span class="st">"/ total de tokens únicos:"</span>,<span class="fu">length</span>(<span class="fu">unique</span>(tokens.nuvem))))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Total de tokens: 2477 / total de tokens únicos: 1565"</code></pre>
</div>
</div>
<p>E geramos novamente o <code>data.frame</code> e o gráfico com as palavras de parada removidas:</p>
<div id="cell-30" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a><span class="co"># converte vetor para data.frame (novamente)</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>tokens.nuvem.df <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">table</span>(tokens.nuvem))</span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="co"># remove margins para comportar a nuvem</span></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>))</span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="co"># gera nuvem</span></span>
<span id="cb30-6"><a href="#cb30-6"></a><span class="fu">wordcloud</span>(tokens.nuvem.df<span class="sc">$</span>tokens.nuvem, tokens.nuvem.df<span class="sc">$</span>Freq, <span class="at">colors=</span><span class="fu">brewer.pal</span>(<span class="dv">8</span>, <span class="st">"Spectral"</span>),<span class="at">random.order=</span><span class="cn">FALSE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="aula-03_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="lematização-e-radicalização" class="level3">
<h3 class="anchored" data-anchor-id="lematização-e-radicalização">Lematização e radicalização</h3>
<p>A <em>lematização</em> transforma o <em>corpus</em> de modo que as variações das unidades linguísticas (<em>lexemas</em>) sejam substituídas representações canônicas (<em>lemas</em>), que não prejudicam o entendimento do texto.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Lexema</th>
<th>Lema</th>
<th>Raiz</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>algum, alguns, alguma, algumas</td>
<td>algum</td>
<td>algu_</td>
</tr>
</tbody>
</table>
<p>A <em>radicalização</em> identifica o morfema básico da unidade, de modo a remover as variações morfológicas. Este processo retorna <em>tokens</em> ainda mais simples, reduzindo-os às suas formas sem variação de gênero, número, classe gramatical, tempo verbal etc.</p>
<p>O símbolo <code>_</code> (sublinhado) na tabela delimita o radical e sua aplicação ao corpus consistiria na substituição de todos os <em>lexemas</em> pela forma reduzida. Qualquer outro símbolo pode ser selecionado para tal indicação.</p>
<p>O processo de lematização e radicalização deve partir da inspeção do vocabulário tratado. O código a seguir exporta o data.frame <code>tokens.nuvem.df</code> para que esta avaliação seja feita no Microsoft Excel.</p>
<div id="cell-32" class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a><span class="co"># carrega pacote openxlsx</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="fu">library</span>(openxlsx)</span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="co"># exporta</span></span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="fu">write.xlsx</span>(tokens.nuvem.df,<span class="st">"./dados/tokens-nuvem.xlsx"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Considerando o caso da raiz <code>algu_</code>, a inspeção da planilha gerada resultaria na seguinte situação:</p>
<div class="columns">
<div class="column" style="width:50%;">
<table class="caption-top table">
<thead>
<tr class="header">
<th>token</th>
<th style="text-align: center;">frequência</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>alguma</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td>algumas</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="odd">
<td>alguns</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td><strong>algu_</strong></td>
<td style="text-align: center;"><strong>4</strong></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>A substituição de <em>todas</em> ocorrências de <code>alguma</code>, <code>algumas</code> e <code>alguns</code> por <code>algu_</code> pode ser feita pelo próximo trecho de código. Note que retomamos o vetor original, com os dados brutos do poema, e reaplicamos <em>todas</em> as transformações anteriores.</p>
<blockquote class="blockquote">
<p><strong>Dica</strong>: escolha bem o nome das variáveis em R, pois isso pode facilitar a reprodução de transformações e processamentos sequenciais dos dados.</p>
</blockquote>
<div id="cell-34" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a><span class="co"># converte o vetor original para minúsculas</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>tokens.minusculas <span class="ot">&lt;-</span> <span class="fu">str_to_lower</span>(potira)</span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="co"># substitui lexemas pelo radical algum*</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>tokens.minusculas <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(tokens.minusculas, <span class="st">"</span><span class="sc">\\</span><span class="st">balgu[:alpha:]*"</span>,<span class="st">"algu_"</span>)</span>
<span id="cb32-5"><a href="#cb32-5"></a><span class="co"># tokeniza vetor completo do poema</span></span>
<span id="cb32-6"><a href="#cb32-6"></a>tokens.minusculas <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">str_split</span>(tokens.minusculas,<span class="fu">boundary</span>(<span class="st">'word'</span>)))</span>
<span id="cb32-7"><a href="#cb32-7"></a><span class="co"># lista de termos para remover</span></span>
<span id="cb32-8"><a href="#cb32-8"></a>remover <span class="ot">&lt;-</span> <span class="fu">which</span>(tokens.minusculas <span class="sc">%in%</span> <span class="fu">stopwords</span>(<span class="st">'pt'</span>))</span>
<span id="cb32-9"><a href="#cb32-9"></a><span class="co"># remove</span></span>
<span id="cb32-10"><a href="#cb32-10"></a>tokens.nuvem <span class="ot">&lt;-</span> tokens.minusculas[<span class="sc">-</span>remover]</span>
<span id="cb32-11"><a href="#cb32-11"></a><span class="co"># converte vetor para data.frame (novamente)</span></span>
<span id="cb32-12"><a href="#cb32-12"></a>tokens.nuvem.df <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">table</span>(tokens.nuvem))</span>
<span id="cb32-13"><a href="#cb32-13"></a><span class="co"># informa a quantidade de ocorrências de algu_</span></span>
<span id="cb32-14"><a href="#cb32-14"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Ocorrências de algu_:"</span>,<span class="fu">length</span>(<span class="fu">which</span>(<span class="fu">str_detect</span>(tokens.nuvem,<span class="st">"algu_"</span>)))))</span>
<span id="cb32-15"><a href="#cb32-15"></a><span class="co"># remove margins para comportar a nuvem</span></span>
<span id="cb32-16"><a href="#cb32-16"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>))</span>
<span id="cb32-17"><a href="#cb32-17"></a><span class="co"># gera nuvem</span></span>
<span id="cb32-18"><a href="#cb32-18"></a><span class="fu">wordcloud</span>(tokens.nuvem.df<span class="sc">$</span>tokens.nuvem, tokens.nuvem.df<span class="sc">$</span>Freq, <span class="at">colors=</span><span class="fu">brewer.pal</span>(<span class="dv">8</span>, <span class="st">"Spectral"</span>),<span class="at">random.order=</span><span class="cn">FALSE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Ocorrências de algu_: 6"</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="aula-03_files/figure-html/cell-17-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sintaxe" class="level2">
<h2 class="anchored" data-anchor-id="sintaxe">2.2 Sintaxe</h2>
<p>O nível mais simples de ordenação das unidades linguísticas envolve o respeito à sequência de <em>tokens</em> nas frases. A análise estritamente morfológica é baseada na técnica <em>Bag of Words</em>, que trata <em>tokens</em> de modo indiferenciado, sem considerar seus contextos de aparição e as possíveis relações com demais <em>tokens</em>.</p>
<section id="explorando-n-grams" class="level3">
<h3 class="anchored" data-anchor-id="explorando-n-grams">Explorando n-grams</h3>
<p>Para evoluir a análise, podemos tanto definir <em>n-grams</em>, que são composições de <em>n</em> unidades de interesse, como se fossem expressões que aparecem no vocabulário.</p>
<blockquote class="blockquote">
<p><strong>Dica</strong>: a análise morfológica oferece pistas de possíveis combinações de unidades em expressões.</p>
</blockquote>
<p>Vamos verificar os contextos das palavras <code>olhos</code> (<em>f</em>=24):</p>
<ul>
<li><code>str_detect()</code> recebe o documento em que ocorrerá a busca e o padrão de busca;</li>
<li>O padrão de busca <code>\\bpotira\\b</code> significa que buscamos a palavra <em>olhos</em>, o que requer encapsulá-la entre os marcadores <code>\\b</code>;</li>
<li>O resultado de <code>str_detect()</code> é um vetor do tamanho de <code>potira</code>, indicando <code>TRUE</code> onde o padrão foi encontrado e <code>FALSE</code> onde não foi;</li>
<li><code>which()</code> transforma o vetor de <code>TRUE</code> e <code>FALSE</code> nos índices de <code>potira</code>, permitindo que o vetor <code>doc.olhos</code> seja criado com as ocorrências.</li>
</ul>
<div id="cell-36" class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a><span class="co"># localiza 'olhos' nos documentos</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>doc.olhos <span class="ot">&lt;-</span> potira[<span class="fu">which</span>(<span class="fu">str_detect</span>(potira,<span class="st">"</span><span class="sc">\\</span><span class="st">bolhos</span><span class="sc">\\</span><span class="st">b"</span>))]</span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="co"># imprime resultado</span></span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="fu">print</span>(doc.olhos)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "Quando a aldeia surgiu aos olhos torvos"       
 [2] "Nas veias ferve do índio. Os olhos luzem"      
 [3] "Da cativa gentil cerrados olhos"               
 [4] "Potira acorda, os olhos lança em torno,"       
 [5] "Do terrível tamoio os lindos olhos,"           
 [6] "Disse, e fitando no índio ávidos olhos,"       
 [7] "Crava os olhos no chão; lentas lhe saem"       
 [8] "Lágrimas lhe espremeu dos olhos negros"        
 [9] "Expirou de teu pai nos olhos tristes;"         
[10] "Enquanto a vida alumiar meus olhos."           
[11] "Da sua aldeia aos olhos espantados"            
[12] "A graciosa fronte; os olhos fecha,"            
[13] "Se, alguma vez, fugindo a estranhos olhos,"    
[14] "De seus olhos azuis e alegres penas"           
[15] "— “Pois que à taba voltaste, em que teus olhos"
[16] "Que há de acender nestes cansados olhos"       
[17] "Não expirar aos olhos de outros homens;"       
[18] "De olhos que amor venceu: — macia relva,"      
[19] "Anajê crava nela os olhos turvos"              
[20] "Os olhos. Foi desmaio de tristeza"             
[21] "Que desvalia aos olhos teus me coube,"         
[22] "Turvos olhos: “Perdôo-te!” murmura,"           </code></pre>
</div>
</div>
<p>A partir do novo vetor, podemos buscar ocorrências de <code>olhos</code> como antecedente ou consequente do bigram. Por exemplo:</p>
<pre><code> [1] "olhos torvos" 
 [2] "cerrados olhos"
 [8] "olhos negros"
[19] "olhos turvos"</code></pre>
<p>Podemos refazer a limpeza do vetor, excluindo pontuação e palavras de parada, de modo a deixar apenas termos que contribuam para o significado de <code>olhos</code> no contexto.</p>
<div id="cell-38" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1"></a><span class="co"># remove pontuação</span></span>
<span id="cb37-2"><a href="#cb37-2"></a>doc.olhos <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(doc.olhos,<span class="st">"[:punct:]"</span>,<span class="st">""</span>)</span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="co"># transforma em caixa baixa</span></span>
<span id="cb37-4"><a href="#cb37-4"></a>doc.olhos <span class="ot">&lt;-</span> <span class="fu">str_to_lower</span>(doc.olhos)</span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="co"># remove palavras de parada</span></span>
<span id="cb37-6"><a href="#cb37-6"></a><span class="co"># obs: concatenamos stopwords com o símbolo de ou (|) e identificadores de palavra (\\b)</span></span>
<span id="cb37-7"><a href="#cb37-7"></a>doc.olhos <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(doc.olhos,</span>
<span id="cb37-8"><a href="#cb37-8"></a>  <span class="fu">str_c</span>(</span>
<span id="cb37-9"><a href="#cb37-9"></a>    <span class="fu">str_c</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>,<span class="fu">stopwords</span>(<span class="st">"pt"</span>),<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>),</span>
<span id="cb37-10"><a href="#cb37-10"></a>    <span class="at">collapse=</span><span class="st">"|"</span>),</span>
<span id="cb37-11"><a href="#cb37-11"></a>    <span class="st">""</span>)</span>
<span id="cb37-12"><a href="#cb37-12"></a><span class="co"># remove palavras de parada personalizadas</span></span>
<span id="cb37-13"><a href="#cb37-13"></a>palavras.de.parada.olhos <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"os"</span>,<span class="st">"dos"</span>,<span class="st">"de"</span>)</span>
<span id="cb37-14"><a href="#cb37-14"></a><span class="co"># lista de termos para remover</span></span>
<span id="cb37-15"><a href="#cb37-15"></a>doc.olhos <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(doc.olhos,<span class="fu">str_c</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>,palavras.de.parada.olhos,<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>,<span class="at">collapse=</span><span class="st">"|"</span>),<span class="st">""</span>)</span>
<span id="cb37-16"><a href="#cb37-16"></a><span class="co"># remove espaços duplos</span></span>
<span id="cb37-17"><a href="#cb37-17"></a>doc.olhos <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(doc.olhos,<span class="st">"</span><span class="sc">\\</span><span class="st">s+"</span>,<span class="st">" "</span>)</span>
<span id="cb37-18"><a href="#cb37-18"></a><span class="co"># remove espaços no começo</span></span>
<span id="cb37-19"><a href="#cb37-19"></a>doc.olhos <span class="ot">&lt;-</span> <span class="fu">str_trim</span>(doc.olhos,<span class="at">side=</span><span class="st">"both"</span>)</span>
<span id="cb37-20"><a href="#cb37-20"></a><span class="co"># imprime resultado</span></span>
<span id="cb37-21"><a href="#cb37-21"></a><span class="fu">print</span>(doc.olhos)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "aldeia surgiu olhos torvos"         "veias ferve índio olhos luzem"     
 [3] "cativa gentil cerrados olhos"       "potira acorda olhos lança torno"   
 [5] "terrível tamoio lindos olhos"       "disse fitando índio ávidos olhos"  
 [7] "crava olhos chão lentas saem"       "lágrimas espremeu olhos negros"    
 [9] "expirou pai olhos tristes"          "enquanto vida alumiar olhos"       
[11] "aldeia olhos espantados"            "graciosa fronte olhos fecha"       
[13] "alguma vez fugindo estranhos olhos" "olhos azuis alegres penas"         
[15] "pois taba voltaste olhos"           "acender nestes cansados olhos"     
[17] "expirar olhos outros homens"        "olhos amor venceu macia relva"     
[19] "anajê crava nela olhos turvos"      "olhos desmaio tristeza"            
[21] "desvalia olhos coube"               "turvos olhos perdôote murmura"     </code></pre>
</div>
</div>
</section>
<section id="ampliando-a-janela" class="level3">
<h3 class="anchored" data-anchor-id="ampliando-a-janela">Ampliando a janela</h3>
<p>A expressão regular para extrair a palavra <code>olhos</code> acompanhada de uma (01) palavra <em>antes</em> ou <em>depois</em> combina trechos utilizados anteriormente ao operador <code>|</code>, que significa “ou”:</p>
<div id="cell-40" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1"></a><span class="co"># extrai x+olhos e olhos+x</span></span>
<span id="cb39-2"><a href="#cb39-2"></a>doc.olhos <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">str_extract_all</span>(doc.olhos,<span class="st">"</span><span class="sc">\\</span><span class="st">b[:alpha:]+</span><span class="sc">\\</span><span class="st">b</span><span class="sc">\\</span><span class="st">s</span><span class="sc">\\</span><span class="st">bolhos</span><span class="sc">\\</span><span class="st">b|</span><span class="sc">\\</span><span class="st">bolhos</span><span class="sc">\\</span><span class="st">b</span><span class="sc">\\</span><span class="st">s</span><span class="sc">\\</span><span class="st">b[:alpha:]+</span><span class="sc">\\</span><span class="st">b"</span>))</span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="fu">print</span>(doc.olhos)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "surgiu olhos"    "índio olhos"     "cerrados olhos"  "acorda olhos"   
 [5] "lindos olhos"    "ávidos olhos"    "crava olhos"     "espremeu olhos" 
 [9] "pai olhos"       "alumiar olhos"   "aldeia olhos"    "fronte olhos"   
[13] "estranhos olhos" "olhos azuis"     "voltaste olhos"  "cansados olhos" 
[17] "expirar olhos"   "olhos amor"      "nela olhos"      "olhos desmaio"  
[21] "desvalia olhos"  "turvos olhos"   </code></pre>
</div>
</div>
<p>Eventualmente, podemos avaliar que uma palavra adicional é insuficiente para avaliar o contexto de ocorrência de <em>tokens</em> de interesse. Podemos selecionar, por exemplo, uma <em>janela</em> mais ampla e incluir uma palavra <em>antes</em> e outra <em>após</em> aquela sob investigação.</p>
<p>O código a seguir refaz o percurso inteiro com este objetivo, gerando o vetor <code>doc.olhos.tri</code> <em>com</em> e <em>sem</em> palavras de parada para comparação:</p>
<div id="cell-42" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1"></a><span class="co"># ---------------------------------</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="co"># 1) com palavras de parada</span></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="co"># ---------------------------------</span></span>
<span id="cb41-4"><a href="#cb41-4"></a><span class="co"># localiza 'olhos' nos documentos</span></span>
<span id="cb41-5"><a href="#cb41-5"></a>doc.olhos.tri <span class="ot">&lt;-</span> potira[<span class="fu">which</span>(<span class="fu">str_detect</span>(potira,<span class="st">"</span><span class="sc">\\</span><span class="st">bolhos</span><span class="sc">\\</span><span class="st">b"</span>))]</span>
<span id="cb41-6"><a href="#cb41-6"></a><span class="co"># remove pontuação</span></span>
<span id="cb41-7"><a href="#cb41-7"></a>doc.olhos.tri <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(doc.olhos.tri,<span class="st">"[:punct:]"</span>,<span class="st">""</span>)</span>
<span id="cb41-8"><a href="#cb41-8"></a><span class="co"># transforma em caixa baixa</span></span>
<span id="cb41-9"><a href="#cb41-9"></a>doc.olhos.tri <span class="ot">&lt;-</span> <span class="fu">str_to_lower</span>(doc.olhos.tri)</span>
<span id="cb41-10"><a href="#cb41-10"></a><span class="co"># extrai janela x+olhos+y</span></span>
<span id="cb41-11"><a href="#cb41-11"></a>doc.olhos.tri <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">str_extract_all</span>(doc.olhos.tri,<span class="st">"</span><span class="sc">\\</span><span class="st">b[:alpha:]+</span><span class="sc">\\</span><span class="st">b</span><span class="sc">\\</span><span class="st">s</span><span class="sc">\\</span><span class="st">bolhos</span><span class="sc">\\</span><span class="st">b</span><span class="sc">\\</span><span class="st">s</span><span class="sc">\\</span><span class="st">b[:alpha:]+</span><span class="sc">\\</span><span class="st">b"</span>))</span>
<span id="cb41-12"><a href="#cb41-12"></a><span class="fu">print</span>(doc.olhos.tri)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "aos olhos torvos"      "os olhos luzem"        "os olhos lança"       
 [4] "os olhos no"           "dos olhos negros"      "nos olhos tristes"    
 [7] "aos olhos espantados"  "os olhos fecha"        "seus olhos azuis"     
[10] "aos olhos de"          "de olhos que"          "os olhos turvos"      
[13] "os olhos foi"          "aos olhos teus"        "turvos olhos perdôote"</code></pre>
</div>
</div>
<div id="cell-43" class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1"></a><span class="co"># ---------------------------------</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="co"># 2) sem palavras de parada</span></span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="co"># ---------------------------------</span></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="co"># localiza 'olhos' nos documentos</span></span>
<span id="cb43-5"><a href="#cb43-5"></a>doc.olhos.tri.sem <span class="ot">&lt;-</span> potira[<span class="fu">which</span>(<span class="fu">str_detect</span>(potira,<span class="st">"</span><span class="sc">\\</span><span class="st">bolhos</span><span class="sc">\\</span><span class="st">b"</span>))]</span>
<span id="cb43-6"><a href="#cb43-6"></a><span class="co"># remove pontuação</span></span>
<span id="cb43-7"><a href="#cb43-7"></a>doc.olhos.tri.sem <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(doc.olhos.tri.sem,<span class="st">"[:punct:]"</span>,<span class="st">""</span>)</span>
<span id="cb43-8"><a href="#cb43-8"></a><span class="co"># transforma em caixa baixa</span></span>
<span id="cb43-9"><a href="#cb43-9"></a>doc.olhos.tri.sem <span class="ot">&lt;-</span> <span class="fu">str_to_lower</span>(doc.olhos.tri.sem)</span>
<span id="cb43-10"><a href="#cb43-10"></a>doc.olhos.tri.sem <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(doc.olhos.tri.sem,</span>
<span id="cb43-11"><a href="#cb43-11"></a>  <span class="fu">str_c</span>(</span>
<span id="cb43-12"><a href="#cb43-12"></a>    <span class="fu">str_c</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>,<span class="fu">stopwords</span>(<span class="st">"pt"</span>),<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>),</span>
<span id="cb43-13"><a href="#cb43-13"></a>    <span class="at">collapse=</span><span class="st">"|"</span>),</span>
<span id="cb43-14"><a href="#cb43-14"></a>    <span class="st">""</span>)</span>
<span id="cb43-15"><a href="#cb43-15"></a><span class="co"># remove palavras de parada personalizadas</span></span>
<span id="cb43-16"><a href="#cb43-16"></a>palavras.de.parada.olhos <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"os"</span>,<span class="st">"dos"</span>,<span class="st">"de"</span>)</span>
<span id="cb43-17"><a href="#cb43-17"></a><span class="co"># lista de termos para remover</span></span>
<span id="cb43-18"><a href="#cb43-18"></a>doc.olhos.tri.sem <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(doc.olhos.tri.sem,<span class="fu">str_c</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>,palavras.de.parada.olhos,<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>,<span class="at">collapse=</span><span class="st">"|"</span>),<span class="st">""</span>)</span>
<span id="cb43-19"><a href="#cb43-19"></a><span class="co"># remove espaços duplos</span></span>
<span id="cb43-20"><a href="#cb43-20"></a>doc.olhos.tri.sem <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(doc.olhos.tri.sem,<span class="st">"</span><span class="sc">\\</span><span class="st">s+"</span>,<span class="st">" "</span>)</span>
<span id="cb43-21"><a href="#cb43-21"></a><span class="co"># remove espaços no começo</span></span>
<span id="cb43-22"><a href="#cb43-22"></a>doc.olhos.tri.sem <span class="ot">&lt;-</span> <span class="fu">str_trim</span>(doc.olhos.tri.sem,<span class="at">side=</span><span class="st">"both"</span>)</span>
<span id="cb43-23"><a href="#cb43-23"></a><span class="co"># extrai janela x+olhos+y</span></span>
<span id="cb43-24"><a href="#cb43-24"></a>doc.olhos.tri.sem <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">str_extract_all</span>(doc.olhos.tri.sem,<span class="st">"</span><span class="sc">\\</span><span class="st">b[:alpha:]+</span><span class="sc">\\</span><span class="st">b</span><span class="sc">\\</span><span class="st">s</span><span class="sc">\\</span><span class="st">bolhos</span><span class="sc">\\</span><span class="st">b</span><span class="sc">\\</span><span class="st">s</span><span class="sc">\\</span><span class="st">b[:alpha:]+</span><span class="sc">\\</span><span class="st">b"</span>))</span>
<span id="cb43-25"><a href="#cb43-25"></a><span class="fu">print</span>(doc.olhos.tri.sem)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "surgiu olhos torvos"     "índio olhos luzem"      
 [3] "acorda olhos lança"      "crava olhos chão"       
 [5] "espremeu olhos negros"   "pai olhos tristes"      
 [7] "aldeia olhos espantados" "fronte olhos fecha"     
 [9] "expirar olhos outros"    "nela olhos turvos"      
[11] "desvalia olhos coube"    "turvos olhos perdôote"  </code></pre>
</div>
</div>
<p>A inspeção da distribuição completa de frequências pode ajudar a identificar termos e sentenças que merecem investigação. No entanto, a revisão da literatura sobre o objeto de pesquisa e os resultados dos estudos anteriores podem sugerir palavras a serem exploradas.</p>
<blockquote class="blockquote">
<p><strong>Dica</strong>: Alguns temos parecem ser palavras de parada, mas podem ser modificadores de outras palavras efetivamente importantes, o que nos leva à composição de <em>n-grams</em> no vocabulário. Por exemplo, <em>não</em> transforma o contexto de ocorrência de termos como <em>posso</em>, <em>devo</em> , <em>consigo</em> e <em>faço</em>.</p>
</blockquote>
</section>
</section>
<section id="semântica" class="level2">
<h2 class="anchored" data-anchor-id="semântica">2.3 Semântica</h2>
<p>De que modo a frequência de <em>tokens</em> nos documentos pode fornecer indícios sobre os temas de que tratam o conjunto de dados? Como vimos, a contagem de frequência de lexemas em <em>sacos de palavras</em> não permite considerar a sintaxe das sentenças, tampouco as relações entre <em>tokens</em> utilizados nos registros textuais.</p>
<section id="a-frequência-relativa-da-palavra-tf" class="level3">
<h3 class="anchored" data-anchor-id="a-frequência-relativa-da-palavra-tf">A frequência relativa da palavra: <em>tf</em></h3>
<p>Em vez de realizar a contagem absoluta, o quociente entre a frequência de ocorrência total do termo no documento (<span class="math inline">f_{t,d}</span>) e o total de termos que o documento emprega (<span class="math inline">\Sigma_{t'\in d}</span>).</p>
<p><span id="eq-tf"><span class="math display">
tf(t,d)=\frac{f_{t,d}}{\Sigma_{t'\in d}}
\tag{1}</span></span></p>
<p>Para exemplificar a computação desta medida, trataremos toda a coleção dos textos de Machado de Assis entre 1870 e 1879. Avaliaremos as medidas de cada termo do vocabulário completo da coleção, aplicando o processo pela normalização e limpeza dos poemas apresentado anteriormente.</p>
<div id="cell-47" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1"></a><span class="co"># ajusta exibição de casas decimais</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="fu">options</span>(<span class="at">scipen=</span><span class="dv">9999</span>)</span>
<span id="cb45-3"><a href="#cb45-3"></a></span>
<span id="cb45-4"><a href="#cb45-4"></a><span class="co"># importa coleção de Machado de Assis</span></span>
<span id="cb45-5"><a href="#cb45-5"></a>colecao <span class="ot">&lt;-</span> <span class="fu">read.xlsx</span>(<span class="st">"1870-1879.xlsx"</span>)</span>
<span id="cb45-6"><a href="#cb45-6"></a></span>
<span id="cb45-7"><a href="#cb45-7"></a><span class="co"># --------------------------------</span></span>
<span id="cb45-8"><a href="#cb45-8"></a><span class="co"># limpeza e normalização dos dados</span></span>
<span id="cb45-9"><a href="#cb45-9"></a><span class="co"># --------------------------------</span></span>
<span id="cb45-10"><a href="#cb45-10"></a><span class="co"># remove pontuação</span></span>
<span id="cb45-11"><a href="#cb45-11"></a>colecao<span class="sc">$</span>texto <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(colecao<span class="sc">$</span>texto,<span class="st">"[:punct:]"</span>,<span class="st">" "</span>)</span>
<span id="cb45-12"><a href="#cb45-12"></a><span class="co"># remove quebras de linha</span></span>
<span id="cb45-13"><a href="#cb45-13"></a>colecao<span class="sc">$</span>texto <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(colecao<span class="sc">$</span>texto,<span class="st">"</span><span class="sc">\\</span><span class="st">n"</span>,<span class="st">" "</span>)</span>
<span id="cb45-14"><a href="#cb45-14"></a><span class="co"># transforma para minúsculas</span></span>
<span id="cb45-15"><a href="#cb45-15"></a>colecao<span class="sc">$</span>texto <span class="ot">&lt;-</span> <span class="fu">str_to_lower</span>(colecao<span class="sc">$</span>texto)</span>
<span id="cb45-16"><a href="#cb45-16"></a><span class="co"># remove palavras de parada</span></span>
<span id="cb45-17"><a href="#cb45-17"></a>colecao<span class="sc">$</span>texto <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(colecao<span class="sc">$</span>texto,<span class="fu">str_c</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>,<span class="fu">stopwords</span>(<span class="st">'pt'</span>),<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>,<span class="at">collapse=</span><span class="st">"|"</span>),<span class="st">" "</span>)</span>
<span id="cb45-18"><a href="#cb45-18"></a><span class="co"># remove espaços duplicados</span></span>
<span id="cb45-19"><a href="#cb45-19"></a>colecao<span class="sc">$</span>texto <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(colecao<span class="sc">$</span>texto,<span class="st">"</span><span class="sc">\\</span><span class="st">s{1,}"</span>,<span class="st">" "</span>)</span>
<span id="cb45-20"><a href="#cb45-20"></a><span class="co"># remove espaços extras no início e final</span></span>
<span id="cb45-21"><a href="#cb45-21"></a>colecao<span class="sc">$</span>texto <span class="ot">&lt;-</span> <span class="fu">str_trim</span>(colecao<span class="sc">$</span>texto,<span class="at">side=</span><span class="st">"both"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>O <code>data.frame</code> normalizado pode então ser transformado no vocabulário:</p>
<div id="cell-49" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1"></a><span class="co"># tokeniza vetor completo </span></span>
<span id="cb46-2"><a href="#cb46-2"></a>colecao.tokens <span class="ot">&lt;-</span> <span class="fu">unique</span>(<span class="fu">unlist</span>(<span class="fu">str_split</span>(colecao<span class="sc">$</span>texto,<span class="fu">boundary</span>(<span class="st">'word'</span>))))</span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="co"># informa a quantidade de tokens</span></span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Total de tokens:"</span>,<span class="fu">length</span>(colecao.tokens)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Total de tokens: 14362"</code></pre>
</div>
</div>
<p>O denominador da equação 1 corresponde aos <strong>14.362</strong> <em>tokens</em> únicos da coleção. Precisaremos calcular a frequência de cada termo em cada documento para completar os dados necessários para o cálculo da medida <em>tf</em>. Os resultados serão registrados no <code>data.frame</code> de nome <code>txd</code> (<em>tokens</em> x documentos).</p>
<p>A primeira coluna de <code>txd</code> registra o total de <em>tokens</em> no documento, para facilitar computações subsequentes. As colunas seguintes correspondem a todos os termos do vocabulário.</p>
<div id="cell-51" class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1"></a><span class="co"># cria data.frame de tokens x documentos</span></span>
<span id="cb48-2"><a href="#cb48-2"></a>txd <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(</span>
<span id="cb48-3"><a href="#cb48-3"></a>  <span class="fu">matrix</span>(</span>
<span id="cb48-4"><a href="#cb48-4"></a>    <span class="at">data=</span><span class="dv">0</span>,</span>
<span id="cb48-5"><a href="#cb48-5"></a>    <span class="at">nrow=</span><span class="fu">nrow</span>(colecao),</span>
<span id="cb48-6"><a href="#cb48-6"></a>    <span class="at">ncol=</span><span class="fu">length</span>(colecao.tokens)<span class="sc">+</span><span class="dv">1</span> <span class="co"># total tokens do documento + frequência token/documento</span></span>
<span id="cb48-7"><a href="#cb48-7"></a>  )</span>
<span id="cb48-8"><a href="#cb48-8"></a>)</span>
<span id="cb48-9"><a href="#cb48-9"></a><span class="co"># define nomes das colunas</span></span>
<span id="cb48-10"><a href="#cb48-10"></a><span class="fu">colnames</span>(txd) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"total.tokens"</span>,colecao.tokens)</span>
<span id="cb48-11"><a href="#cb48-11"></a><span class="co"># define nomes das linhas</span></span>
<span id="cb48-12"><a href="#cb48-12"></a><span class="fu">rownames</span>(txd) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(</span>
<span id="cb48-13"><a href="#cb48-13"></a>  <span class="st">"doc"</span>, <span class="co"># prefixo</span></span>
<span id="cb48-14"><a href="#cb48-14"></a>  <span class="fu">seq</span>(<span class="dv">1</span>, <span class="co"># valor inicial</span></span>
<span id="cb48-15"><a href="#cb48-15"></a>    <span class="fu">nrow</span>(colecao), <span class="co"># valor final</span></span>
<span id="cb48-16"><a href="#cb48-16"></a>    <span class="dv">1</span>    <span class="co"># incremento</span></span>
<span id="cb48-17"><a href="#cb48-17"></a>  )</span>
<span id="cb48-18"><a href="#cb48-18"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A matrix <code>txd</code> é do tipo <em>esparsa</em>, uma vez que terá muitas células com valor zero, referentes aos documentos em que um dado termo não ocorre. A partir dela, criaremos a matriz <code>txd.tf</code>, que registrará a frequência relativa de cada <em>token</em>.</p>
<blockquote class="blockquote">
<p><strong>Dica</strong>: podemos aproveitar a estrutura de <code>txd.tf</code> para a matriz <code>txd.tfidf</code> que será explicada na próxima seção. A estrutura é exatamente a mesma, mas os valores armazenados são diferentes.</p>
</blockquote>
<div id="cell-53" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a><span class="co"># cria data.frame para as medidas tf tokens x documentos</span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="co"># (primeira coluna com totais é desnecessária)</span></span>
<span id="cb49-3"><a href="#cb49-3"></a>txd.tf <span class="ot">&lt;-</span> txd[,<span class="fu">c</span>(<span class="dv">2</span><span class="sc">:</span><span class="fu">ncol</span>(txd))]</span>
<span id="cb49-4"><a href="#cb49-4"></a></span>
<span id="cb49-5"><a href="#cb49-5"></a><span class="co"># aproveita estrutura para tf-idf</span></span>
<span id="cb49-6"><a href="#cb49-6"></a>txd.tfidf <span class="ot">&lt;-</span> txd.tf</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>O trecho de código abaixo é responsável por contar as ocorrências de cada <em>token</em> por documento. Este processo tem quatro etapas principais:</p>
<ul>
<li>Linha 4: atribuímos a <code>doc.tokens</code> a contagem total de <em>tokens</em> em <code>documento</code> a partir da tokenização realizada pela função <code>str_split()</code></li>
<li>Linhas 10 a 17: <code>freq.token</code> registra a frequência de <code>token</code> em <code>documento</code> utilizando a função <code>str_match_all()</code></li>
<li>Linha 19: registramos <code>freq.token</code> em <code>txd</code></li>
<li>Linha 21: calculamos a frequência ponderada (<em>tf</em>) propriamente dita</li>
</ul>
<blockquote class="blockquote">
<p><strong>Dica</strong>: o <em>script</em> a seguir é intensivo em processamento, podendo demorar cerca de <em>5 minutos</em> para ser executado. Para evitar o tempo de espera, exporte a planilha resultante e a importe antes dos processamentos seguintes.</p>
</blockquote>
<div id="cell-55" class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1"></a><span class="co"># contagem das frequências</span></span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="cf">for</span> (documento <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(colecao)) {</span>
<span id="cb50-3"><a href="#cb50-3"></a>  <span class="co"># total de tokens do documento</span></span>
<span id="cb50-4"><a href="#cb50-4"></a>  doc.tokens <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">unlist</span>(<span class="fu">str_split</span>(colecao<span class="sc">$</span>texto[documento],<span class="fu">boundary</span>(<span class="st">'word'</span>))))</span>
<span id="cb50-5"><a href="#cb50-5"></a>  <span class="co"># inclui na matriz</span></span>
<span id="cb50-6"><a href="#cb50-6"></a>  txd<span class="sc">$</span>total.tokens[documento] <span class="ot">&lt;-</span> doc.tokens</span>
<span id="cb50-7"><a href="#cb50-7"></a>  <span class="co"># conta ocorrências de cada token no documento</span></span>
<span id="cb50-8"><a href="#cb50-8"></a>  <span class="cf">for</span> (token <span class="cf">in</span> colecao.tokens) {</span>
<span id="cb50-9"><a href="#cb50-9"></a>    <span class="co"># computa</span></span>
<span id="cb50-10"><a href="#cb50-10"></a>    freq.token <span class="ot">&lt;-</span> <span class="fu">length</span>(</span>
<span id="cb50-11"><a href="#cb50-11"></a>      <span class="fu">unlist</span>(</span>
<span id="cb50-12"><a href="#cb50-12"></a>        <span class="fu">str_match_all</span>(</span>
<span id="cb50-13"><a href="#cb50-13"></a>          colecao<span class="sc">$</span>texto[documento],</span>
<span id="cb50-14"><a href="#cb50-14"></a>          <span class="fu">str_c</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>,token,<span class="st">"</span><span class="sc">\\</span><span class="st">b"</span>)</span>
<span id="cb50-15"><a href="#cb50-15"></a>        )</span>
<span id="cb50-16"><a href="#cb50-16"></a>      )</span>
<span id="cb50-17"><a href="#cb50-17"></a>    )</span>
<span id="cb50-18"><a href="#cb50-18"></a>    <span class="co"># adiciona à df geral</span></span>
<span id="cb50-19"><a href="#cb50-19"></a>    txd[documento,token] <span class="ot">&lt;-</span> freq.token</span>
<span id="cb50-20"><a href="#cb50-20"></a>    <span class="co"># computa tf</span></span>
<span id="cb50-21"><a href="#cb50-21"></a>    txd.tf[documento,token] <span class="ot">&lt;-</span> freq.token<span class="sc">/</span>doc.tokens</span>
<span id="cb50-22"><a href="#cb50-22"></a>  }</span>
<span id="cb50-23"><a href="#cb50-23"></a>}</span>
<span id="cb50-24"><a href="#cb50-24"></a><span class="co"># Visualiza txd</span></span>
<span id="cb50-25"><a href="#cb50-25"></a><span class="fu">View</span>(txd)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="a-informação-transmitida-pela-palavra-quanto-à-coleção-idf" class="level3">
<h3 class="anchored" data-anchor-id="a-informação-transmitida-pela-palavra-quanto-à-coleção-idf">A informação transmitida pela palavra quanto à coleção: <em>idf</em></h3>
<p>Ao considerarmos a coleção completa de documentos, podemos avaliar o quão <em>rara</em> ou <em>comum</em> uma palavra é.</p>
<p>O <em>inverso da frequência nos documentos</em> ou <em>inverse document frequency (idf)</em> é uma medida quantitativa da frequência <span class="math inline">N</span> do termo <span class="math inline">t</span> na coleção de documentos <span class="math inline">D</span>, definida pelo logaritmo do quociente entre o total de documentos e o número de documentos que contêm o termo:</p>
<p><span id="eq-idf"><span class="math display">
idf(t,D) = log\frac{N}{n_t}
\tag{2}</span></span></p>
<p>Assumindo que o termo está presente na coleção, o denominador <span class="math inline">{n_t}</span> será diferente de zero. Criaremos uma nova matriz, denominada <code>txd.idf</code> para registrar os os resultados da equação 2.</p>
<blockquote class="blockquote">
<p><strong>Dica</strong>: o valor de <em>idf</em> é constante para cada termo na coleção de documentos, de modo que a matriz só terá <em>uma única</em> linha.</p>
</blockquote>
<div id="cell-57" class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1"></a><span class="co"># cria data.frame para as medidas idf dos tokens</span></span>
<span id="cb51-2"><a href="#cb51-2"></a>txd.idf <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">matrix</span>(<span class="at">nrow=</span><span class="dv">1</span>,<span class="at">ncol=</span><span class="fu">length</span>(colecao.tokens),<span class="at">data=</span><span class="dv">0</span>))</span>
<span id="cb51-3"><a href="#cb51-3"></a><span class="fu">colnames</span>(txd.idf) <span class="ot">&lt;-</span> colecao.tokens</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>O cálculo de <em>idf</em> para os termos analisa quantas células das respectivas colunas têm valor maior que zero e atribui o resultado a <code>nt</code> (numerador da equação 2). Em seguida, computamos o logarítmo do quociente entre o número de documentos da coleção, obtido por <code>nrow()</code> e <code>nt</code>.</p>
<div id="cell-59" class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1"></a><span class="co"># laço por documentos e termos</span></span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="cf">for</span> (coluna <span class="cf">in</span> colecao.tokens) {</span>
<span id="cb52-3"><a href="#cb52-3"></a>  <span class="co"># conta ocorrências em todos os documentos</span></span>
<span id="cb52-4"><a href="#cb52-4"></a>  nt <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">which</span>(txd[,coluna] <span class="sc">&gt;</span> <span class="dv">0</span>))</span>
<span id="cb52-5"><a href="#cb52-5"></a>  <span class="co"># calcula idf (somando 1 para evitar divisão por zero)</span></span>
<span id="cb52-6"><a href="#cb52-6"></a>  idf <span class="ot">&lt;-</span> <span class="fu">log10</span>(<span class="fu">nrow</span>(colecao)<span class="sc">/</span>nt)</span>
<span id="cb52-7"><a href="#cb52-7"></a>  <span class="co"># adiciona ao df</span></span>
<span id="cb52-8"><a href="#cb52-8"></a>  txd.idf[<span class="dv">1</span>,coluna] <span class="ot">&lt;-</span> idf</span>
<span id="cb52-9"><a href="#cb52-9"></a>}</span>
<span id="cb52-10"><a href="#cb52-10"></a><span class="co"># Visualiza</span></span>
<span id="cb52-11"><a href="#cb52-11"></a><span class="fu">View</span>(txd.idf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="a-medida-da-importância-do-termo-tf-idf" class="level3">
<h3 class="anchored" data-anchor-id="a-medida-da-importância-do-termo-tf-idf">A medida da importância do termo: <em>tf-idf</em></h3>
<p>Finalmente, a medida <em>tf-idf</em> se refere à importância de <em>tokens</em> (<span class="math inline">t</span>) em documentos (<span class="math inline">d</span>) de uma coleção (<span class="math inline">D</span>) a partir do produto entre a frequência do termo no documento quem estão (<span class="math inline">tf</span>) e a frequência dele no conjunto de documentos (<span class="math inline">idf</span>).</p>
<p><span id="eq-tfidf"><span class="math display">
tfidf(t,d,D)=tf(t,d) \cdot idf(t,D)
\tag{3}</span></span></p>
<p>A equação 3 produz números grandes se a frequência do termo no documento for alta e a frequência dele na coleção for baixa. Pode-se entender tal relação como a capacidade do termo ser um bom indicador para um documento específico, em vez de estar disperso pela coleção.</p>
<p>A matriz esparsa <code>txd.tfidf</code> registra o resultado da multiplicação por documento e termo.</p>
<div id="cell-62" class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1"></a><span class="co"># calcula tf-idf por documento</span></span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="cf">for</span> (documento <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(colecao)) {</span>
<span id="cb53-3"><a href="#cb53-3"></a>  <span class="co"># calcula tf-idf do token no documento</span></span>
<span id="cb53-4"><a href="#cb53-4"></a>  <span class="cf">for</span> (coluna <span class="cf">in</span> colecao.tokens) {</span>
<span id="cb53-5"><a href="#cb53-5"></a>    <span class="co"># tf-idf: idf(termo) * tf(documento,termo)</span></span>
<span id="cb53-6"><a href="#cb53-6"></a>    txd.tfidf[documento,coluna] <span class="ot">&lt;-</span> txd.idf[<span class="dv">1</span>,coluna] <span class="sc">*</span> txd.tf[documento,coluna]</span>
<span id="cb53-7"><a href="#cb53-7"></a>  }</span>
<span id="cb53-8"><a href="#cb53-8"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>O formato “tidy” para <code>data.frames</code> facilita a construção de visualizações pois reduz a quantidade de variáveis. Em vez de mantermos a matriz esparsa, transformamos cada termo no nível de uma coluna <em>token</em>, indicando o documento que ocorre e o valor <em>tf-idf</em> correspondente.</p>
<div id="cell-64" class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1"></a><span class="co"># cria novo df no formato tidy</span></span>
<span id="cb54-2"><a href="#cb54-2"></a>txd.tidy <span class="ot">&lt;-</span> <span class="fu">data.frame</span>()</span>
<span id="cb54-3"><a href="#cb54-3"></a></span>
<span id="cb54-4"><a href="#cb54-4"></a><span class="co"># linhas</span></span>
<span id="cb54-5"><a href="#cb54-5"></a><span class="cf">for</span> (linha <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(txd.tfidf)) {</span>
<span id="cb54-6"><a href="#cb54-6"></a>  <span class="co"># documento</span></span>
<span id="cb54-7"><a href="#cb54-7"></a>  documento <span class="ot">&lt;-</span> <span class="fu">rownames</span>(txd.tfidf)[linha]</span>
<span id="cb54-8"><a href="#cb54-8"></a>  <span class="co"># colunas</span></span>
<span id="cb54-9"><a href="#cb54-9"></a>  <span class="cf">for</span> (coluna <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(txd.tfidf)) {</span>
<span id="cb54-10"><a href="#cb54-10"></a>    <span class="co"># token</span></span>
<span id="cb54-11"><a href="#cb54-11"></a>    token <span class="ot">&lt;-</span> <span class="fu">colnames</span>(txd.tfidf)[coluna]</span>
<span id="cb54-12"><a href="#cb54-12"></a>    <span class="co"># tf-idf</span></span>
<span id="cb54-13"><a href="#cb54-13"></a>    tfidf <span class="ot">&lt;-</span> txd.tfidf[linha,coluna]</span>
<span id="cb54-14"><a href="#cb54-14"></a>    <span class="co"># adiciona ao df se &gt; 0</span></span>
<span id="cb54-15"><a href="#cb54-15"></a>    <span class="cf">if</span> (tfidf <span class="sc">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb54-16"><a href="#cb54-16"></a>      txd.tidy <span class="ot">&lt;-</span> <span class="fu">rbind</span>(txd.tidy, </span>
<span id="cb54-17"><a href="#cb54-17"></a>        <span class="fu">data.frame</span>(</span>
<span id="cb54-18"><a href="#cb54-18"></a>          <span class="st">"doc"</span><span class="ot">=</span>documento,</span>
<span id="cb54-19"><a href="#cb54-19"></a>          <span class="st">"token"</span><span class="ot">=</span>token,</span>
<span id="cb54-20"><a href="#cb54-20"></a>          <span class="st">"tf.idf"</span><span class="ot">=</span>tfidf</span>
<span id="cb54-21"><a href="#cb54-21"></a>        )</span>
<span id="cb54-22"><a href="#cb54-22"></a>      )</span>
<span id="cb54-23"><a href="#cb54-23"></a>    }</span>
<span id="cb54-24"><a href="#cb54-24"></a>  }</span>
<span id="cb54-25"><a href="#cb54-25"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ademais, é interessante gerar o <em>ranking</em> dos termos, isto é, ordená-los de acordo com o valor de <em>tf-idf</em> por documento. Isto facilita a visualização dos <span class="math inline">n</span> termos mais relevantes para um documento ou para toda a coleção.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./imagens/ranking.png" class="img-fluid figure-img"></p>
<figcaption>Visualização da coluna <code>tf.idf</code> para a criação de <em>rankings</em>.</figcaption>
</figure>
</div>
<div id="cell-66" class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1"></a><span class="co"># cria ranking dos tokens</span></span>
<span id="cb55-2"><a href="#cb55-2"></a>txd.tidy<span class="sc">$</span>ranking <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb55-3"><a href="#cb55-3"></a></span>
<span id="cb55-4"><a href="#cb55-4"></a><span class="co"># ordena com base em tf e token por documento</span></span>
<span id="cb55-5"><a href="#cb55-5"></a><span class="cf">for</span> (d <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(txd.tidy)) {</span>
<span id="cb55-6"><a href="#cb55-6"></a>  <span class="co"># documento</span></span>
<span id="cb55-7"><a href="#cb55-7"></a>  doc <span class="ot">&lt;-</span> txd.tidy<span class="sc">$</span>doc[d]</span>
<span id="cb55-8"><a href="#cb55-8"></a>  token.rankings <span class="ot">&lt;-</span> <span class="fu">order</span>(txd.tidy[txd.tidy<span class="sc">$</span>doc<span class="sc">==</span>doc,]<span class="sc">$</span>tf.idf, <span class="at">decreasing =</span> <span class="cn">TRUE</span>)</span>
<span id="cb55-9"><a href="#cb55-9"></a>  <span class="co"># adiciona ordem ao data.frame</span></span>
<span id="cb55-10"><a href="#cb55-10"></a>  txd.tidy[txd.tidy<span class="sc">$</span>doc<span class="sc">==</span>doc,]<span class="sc">$</span>ranking[token.rankings] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(txd.tidy[txd.tidy<span class="sc">$</span>doc<span class="sc">==</span>doc,])</span>
<span id="cb55-11"><a href="#cb55-11"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>O pacote <code>ggplot2</code> reúne funções para a geração de gráficos com base no formato <em>tidy</em>. A figura tem 23 painéis que correspondem a cada documento da coleção e a distribuição da medida <em>tf-idf</em>.</p>
<div id="cell-68" class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1"></a><span class="co"># instala pacote</span></span>
<span id="cb56-2"><a href="#cb56-2"></a><span class="fu">install.packages</span>(<span class="st">'ggplot2'</span>)</span>
<span id="cb56-3"><a href="#cb56-3"></a><span class="co"># carrega pacote</span></span>
<span id="cb56-4"><a href="#cb56-4"></a><span class="fu">library</span>(ggplot2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Installing package into ‘C:/Users/msn/AppData/Local/R/win-library/4.5’
(as ‘lib’ is unspecified)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>trying URL 'https://cran.rstudio.com/bin/windows/contrib/4.5/ggplot2_4.0.1.zip'
Content type 'application/zip' length 8479127 bytes (8.1 MB)
downloaded 8.1 MB
</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>package ‘ggplot2’ successfully unpacked and MD5 sums checked

The downloaded binary packages are in
    C:\Users\msn\AppData\Local\Temp\RtmpyyWmAN\downloaded_packages</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning message:
package ‘ggplot2’ was built under R version 4.5.2 </code></pre>
</div>
</div>
<p>As seguintes funções geram o gráfico:</p>
<ul>
<li><code>ggplot()</code> inicializa o gráfico, recebendo <code>txd.tidy</code> como argumento. Isso expõe as variáveis do <code>data.frame</code> para a construção do gráfico;</li>
<li><code>geom_jitter()</code> marca pontos no gráfico, tendo o <em>ranking</em> do termo no eixo <span class="math inline">X</span> e <em>tf-idf</em> no eixo <span class="math inline">Y</span>;</li>
<li><code>scale_x_log10()</code> e <code>scale_y_log10()</code> definem a escala dos eixos para logarítmica de base 10;</li>
<li><code>xlab()</code> e <code>ylab()</code> mudam os rótulos dos eixos e <code>labs()</code> define o título e subtítulo do gráfico;</li>
<li><code>facet_wrap()</code> cria os painéis do gráfico, controlando pelos documentos (fórmula <code>~doc</code>);</li>
<li><code>theme_minimal()</code> seleciona o tema “minimal”, que é mais limpo e usa menos elementos gráficos.</li>
</ul>
<div id="cell-70" class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1"></a><span class="co"># plota ranking x tf-idf por documento</span></span>
<span id="cb61-2"><a href="#cb61-2"></a><span class="fu">ggplot</span>(txd.tidy) <span class="sc">+</span> </span>
<span id="cb61-3"><a href="#cb61-3"></a>  <span class="fu">geom_jitter</span>(<span class="fu">aes</span>(<span class="at">x=</span>ranking,<span class="at">y=</span>tf.idf),<span class="at">alpha=</span><span class="fl">0.2</span>)<span class="sc">+</span></span>
<span id="cb61-4"><a href="#cb61-4"></a>  <span class="fu">scale_x_log10</span>()<span class="sc">+</span></span>
<span id="cb61-5"><a href="#cb61-5"></a>  <span class="fu">scale_y_log10</span>()<span class="sc">+</span></span>
<span id="cb61-6"><a href="#cb61-6"></a>  <span class="fu">xlab</span>(<span class="st">"Ranking"</span>)<span class="sc">+</span></span>
<span id="cb61-7"><a href="#cb61-7"></a>  <span class="fu">ylab</span>(<span class="st">"tf-idf"</span>)<span class="sc">+</span></span>
<span id="cb61-8"><a href="#cb61-8"></a>  <span class="fu">labs</span>(<span class="at">title=</span><span class="st">"Distribuição de tokens"</span>,<span class="at">subtitle=</span><span class="fu">paste0</span>(<span class="st">"N="</span>,<span class="fu">length</span>(colecao.tokens)))<span class="sc">+</span></span>
<span id="cb61-9"><a href="#cb61-9"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>doc,<span class="at">ncol=</span><span class="dv">5</span>)<span class="sc">+</span></span>
<span id="cb61-10"><a href="#cb61-10"></a>  <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="aula-03_files/figure-html/cell-34-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>O conjunto dos painéis aproxima a distribuição proposta pela <a href="https://en.wikipedia.org/wiki/Zipf%27s_law">Lei de Zipf</a>: a frequência de um termo é inversamente proporcional à sua ordem (<em>ranking</em>) no corpus. Os termos mais à esquerda do gráfico têm ordem baixa e <em>tf-idf</em> alto.</p>
<p>O gráfico da coleção completa oferece outra perspectiva sobre o efeito, acompanhado da reta de regressão em que tentamos predizer o <em>ranking</em> a partir da medida <em>tf-idf</em>.</p>
<div id="cell-72" class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1"></a><span class="co"># calcula regressão</span></span>
<span id="cb62-2"><a href="#cb62-2"></a><span class="fu">print</span>(<span class="fu">lm</span>(<span class="fu">log</span>(ranking) <span class="sc">~</span> <span class="fu">log</span>(tf.idf), <span class="at">data=</span>txd.tidy))</span>
<span id="cb62-3"><a href="#cb62-3"></a></span>
<span id="cb62-4"><a href="#cb62-4"></a><span class="co"># plota ranking x tf-idf por documento</span></span>
<span id="cb62-5"><a href="#cb62-5"></a><span class="fu">ggplot</span>(txd.tidy) <span class="sc">+</span> </span>
<span id="cb62-6"><a href="#cb62-6"></a>  <span class="fu">geom_abline</span>(<span class="at">slope=</span><span class="sc">-</span><span class="fl">1.167</span>,<span class="at">intercept =</span> <span class="sc">-</span><span class="fl">1.305</span>, <span class="at">colour=</span><span class="st">"red"</span>, <span class="at">linetype=</span><span class="dv">2</span>)<span class="sc">+</span></span>
<span id="cb62-7"><a href="#cb62-7"></a>  <span class="fu">geom_jitter</span>(<span class="fu">aes</span>(<span class="at">x=</span>ranking,<span class="at">y=</span>tf.idf,<span class="at">colour=</span>doc),<span class="at">alpha=</span><span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb62-8"><a href="#cb62-8"></a>  <span class="fu">scale_x_log10</span>()<span class="sc">+</span></span>
<span id="cb62-9"><a href="#cb62-9"></a>  <span class="fu">scale_y_log10</span>()<span class="sc">+</span></span>
<span id="cb62-10"><a href="#cb62-10"></a>  <span class="fu">xlab</span>(<span class="st">"Ranking"</span>)<span class="sc">+</span></span>
<span id="cb62-11"><a href="#cb62-11"></a>  <span class="fu">ylab</span>(<span class="st">"tf-idf"</span>)<span class="sc">+</span></span>
<span id="cb62-12"><a href="#cb62-12"></a>  <span class="fu">labs</span>(<span class="at">title=</span><span class="st">"Distribuição de tokens"</span>,<span class="at">subtitle=</span><span class="fu">paste0</span>(<span class="st">"N="</span>,<span class="fu">length</span>(colecao.tokens)))<span class="sc">+</span></span>
<span id="cb62-13"><a href="#cb62-13"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span> </span>
<span id="cb62-14"><a href="#cb62-14"></a>  <span class="fu">theme</span>(<span class="at">legend.position=</span><span class="st">"none"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = log(ranking) ~ log(tf.idf), data = txd.tidy)

Coefficients:
(Intercept)  log(tf.idf)  
     -3.004       -1.167  
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="aula-03_files/figure-html/cell-35-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Finalmente, a nuvem de palavras da coleção completa,baseada na medida <em>tf-idf</em>, sugere termos que parecem relevantes para entender todos os textos: “tomé”, “elisa”, “garcia”, “félix”, “estevão” e “mendonça” são nomes de personagens importantes para cada história.</p>
<div id="cell-74" class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1"></a><span class="co"># remove margins para comportar a nuvem</span></span>
<span id="cb64-2"><a href="#cb64-2"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>))</span>
<span id="cb64-3"><a href="#cb64-3"></a><span class="co"># nuvem de palavras por tf-idf para toda a coleção</span></span>
<span id="cb64-4"><a href="#cb64-4"></a><span class="fu">wordcloud</span>(</span>
<span id="cb64-5"><a href="#cb64-5"></a>  txd.tidy<span class="sc">$</span>token, </span>
<span id="cb64-6"><a href="#cb64-6"></a>  txd.tidy<span class="sc">$</span>tf.idf, </span>
<span id="cb64-7"><a href="#cb64-7"></a>  <span class="at">colors=</span><span class="fu">brewer.pal</span>(<span class="dv">8</span>, <span class="st">"Spectral"</span>),</span>
<span id="cb64-8"><a href="#cb64-8"></a>  <span class="at">random.order=</span><span class="cn">FALSE</span>, </span>
<span id="cb64-9"><a href="#cb64-9"></a>  <span class="at">min.freq =</span> <span class="fl">0.003</span> <span class="co"># tf-idf mínimo (+/- 10º)</span></span>
<span id="cb64-10"><a href="#cb64-10"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="aula-03_files/figure-html/cell-36-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Já em relação a “Americanas”, livro que inclui o poema “Potira”, a nuvem <em>tf-idf</em> igualmente indica personagens, grupos ou entidades relevantes para as histórias.</p>
<div id="cell-76" class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1"></a><span class="co"># reparte matriz para documento 12 (Americanas)</span></span>
<span id="cb65-2"><a href="#cb65-2"></a>txd.doc1 <span class="ot">&lt;-</span> txd.tidy[txd.tidy<span class="sc">$</span>doc<span class="sc">==</span><span class="st">"doc12"</span>,]</span>
<span id="cb65-3"><a href="#cb65-3"></a><span class="fu">wordcloud</span>(</span>
<span id="cb65-4"><a href="#cb65-4"></a>  txd.doc1<span class="sc">$</span>token, </span>
<span id="cb65-5"><a href="#cb65-5"></a>  txd.doc1<span class="sc">$</span>tf.idf,</span>
<span id="cb65-6"><a href="#cb65-6"></a>  <span class="fu">c</span>(<span class="dv">3</span>,.<span class="dv">5</span>), <span class="co"># intervalo do tamanho das palavras</span></span>
<span id="cb65-7"><a href="#cb65-7"></a>  <span class="at">colors=</span><span class="fu">brewer.pal</span>(<span class="dv">8</span>, <span class="st">"Spectral"</span>),</span>
<span id="cb65-8"><a href="#cb65-8"></a>  <span class="at">random.order=</span><span class="cn">FALSE</span>, </span>
<span id="cb65-9"><a href="#cb65-9"></a>  <span class="at">min.freq =</span> <span class="fl">0.0005</span> <span class="co"># tf-idf mínimo (+/- 100º)</span></span>
<span id="cb65-10"><a href="#cb65-10"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="aula-03_files/figure-html/cell-37-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Finalmente, devemos exportar todos os dados gerados para facilitar seu reuso em <em>notebooks</em> futuros.</p>
<div id="cell-78" class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1"></a><span class="co"># exportação de todo o processo (descomente para exportar)</span></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="co">#write.xlsx(txd,"./dados/txd.xlsx")</span></span>
<span id="cb66-3"><a href="#cb66-3"></a><span class="co">#write.xlsx(txd.tf,"./dados/txd-tf.xlsx")</span></span>
<span id="cb66-4"><a href="#cb66-4"></a><span class="co">#write.xlsx(txd.idf,"./dados/txd-idf.xlsx")</span></span>
<span id="cb66-5"><a href="#cb66-5"></a><span class="co">#write.xlsx(txd.tfidf,"./dados/txd-tfidf.xlsx")</span></span>
<span id="cb66-6"><a href="#cb66-6"></a><span class="co">#write.xlsx(txd.tidy,"./dados/txd-tidy.xlsx")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>
<section id="atividade" class="level1">
<h1>Atividade</h1>
<p>Selecione entre cinco (5) e dez (10) obras da base <code>1870-1879.xlsx</code> e realize as seguintes investigações:</p>
<ol type="1">
<li>Gere a nuvem de palavras de cada obra;</li>
<li>Calcule as métricas <em>tf</em>, <em>idf</em> e <em>tf-idf</em>;</li>
<li>Indique, a partir das métricas, quais <em>tokens</em> seriam mais importantes para cada obra.</li>
</ol>
<blockquote class="blockquote">
<p><strong>Dica</strong>: o notebook <a href="aula-3-quanteda.html">aula-3-quanteda.ipynb</a> exemplifica <em>todas</em> as operações necessárias para uma (1) obra, utilizando o pacote <code>quanteda</code>. Sua sintaxe é mais simples, embora menos explícita 😉. Em caso de dúvidas, consulte a <a href="https://quanteda.io/reference/index.html">documentação</a>.</p>
</blockquote>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>